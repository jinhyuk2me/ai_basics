## TL;DR
- **그래프 탐색 알고리즘**(BFS, DFS)은 연결성, 순환, 최단 경로 등 그래프의 기본 구조를 파악하는 핵심 도구다.
- **최단 경로 알고리즘**(Dijkstra, Bellman-Ford, Floyd-Warshall)은 네비게이션, 라우팅, 추천 시스템에서 직접 활용된다.
- **최소 신장 트리**(MST), **위상 정렬**, **중앙성** 등은 네트워크 설계, 작업 스케줄링, 영향력 분석의 이론적 기반이다.

---

## 1. 핵심 개념

### 1.1 그래프 탐색의 중요성

**목적**:
- 연결 요소 찾기
- 순환(cycle) 탐지
- 최단 경로 계산
- 위상 정렬

**두 가지 기본 전략**:
- **BFS** (Breadth-First Search): 너비 우선, 레벨별 탐색
- **DFS** (Depth-First Search): 깊이 우선, 백트래킹

---

## 2. BFS (Breadth-First Search)

### 2.1 알고리즘

**아이디어**:
시작 노드에서 가까운 노드부터 방문 (레벨 순서)

**의사 코드**:
```
BFS(G, start):
    queue = [start]
    visited = {start}

    while queue not empty:
        u = queue.dequeue()
        for each neighbor v of u:
            if v not visited:
                visited.add(v)
                queue.enqueue(v)
```

**특징**:
- **시간 복잡도**: $O(|V| + |E|)$
- **공간 복잡도**: $O(|V|)$ (queue + visited)
- **최단 경로**: 무가중 그래프에서 최단 경로 보장

### 2.2 응용

**1. 최단 경로 (무가중)**:
```python
from collections import deque

def bfs_shortest_path(graph, start, goal):
    queue = deque([(start, [start])])
    visited = {start}

    while queue:
        node, path = queue.popleft()
        if node == goal:
            return path

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None  # 경로 없음
```

**2. 연결 요소 개수**:
```python
def count_components(graph):
    visited = set()
    count = 0

    for node in graph:
        if node not in visited:
            # BFS로 연결된 모든 노드 방문
            queue = deque([node])
            visited.add(node)

            while queue:
                u = queue.popleft()
                for v in graph[u]:
                    if v not in visited:
                        visited.add(v)
                        queue.append(v)

            count += 1

    return count
```

**3. 이분 그래프 판별 (2-coloring)**:
```python
def is_bipartite(graph):
    color = {}

    for start in graph:
        if start in color:
            continue

        queue = deque([start])
        color[start] = 0

        while queue:
            u = queue.popleft()
            for v in graph[u]:
                if v not in color:
                    color[v] = 1 - color[u]
                    queue.append(v)
                elif color[v] == color[u]:
                    return False  # 홀수 순환 발견

    return True
```

---

## 3. DFS (Depth-First Search)

### 3.1 알고리즘

**아이디어**:
한 경로를 끝까지 탐색 후 백트래킹

**의사 코드** (재귀):
```
DFS(G, u, visited):
    visited.add(u)
    for each neighbor v of u:
        if v not visited:
            DFS(G, v, visited)
```

**반복 버전** (스택):
```
DFS_iterative(G, start):
    stack = [start]
    visited = {start}

    while stack not empty:
        u = stack.pop()
        for each neighbor v of u:
            if v not visited:
                visited.add(v)
                stack.push(v)
```

**특징**:
- **시간 복잡도**: $O(|V| + |E|)$
- **공간 복잡도**: $O(|V|)$ (recursion stack 또는 explicit stack)
- **순환 탐지**, **위상 정렬**에 유리

### 3.2 응용

**1. 순환 탐지 (무방향 그래프)**:
```python
def has_cycle_undirected(graph):
    visited = set()

    def dfs(node, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                return True  # 순환 발견 (부모 아닌 이미 방문한 노드)
        return False

    for node in graph:
        if node not in visited:
            if dfs(node, None):
                return True

    return False
```

**2. 위상 정렬 (DAG)**:
```python
def topological_sort(graph):
    visited = set()
    stack = []

    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        stack.append(node)  # 후위 순서로 추가

    for node in graph:
        if node not in visited:
            dfs(node)

    return stack[::-1]  # 역순
```

**3. 강연결 요소 (Kosaraju's Algorithm)**:
```python
def strongly_connected_components(graph):
    # Step 1: DFS로 완료 순서 기록
    visited = set()
    finish_order = []

    def dfs1(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs1(neighbor)
        finish_order.append(node)

    for node in graph:
        if node not in visited:
            dfs1(node)

    # Step 2: Transpose graph
    transpose = {node: [] for node in graph}
    for u in graph:
        for v in graph[u]:
            transpose[v].append(u)

    # Step 3: DFS on transpose in reverse finish order
    visited.clear()
    sccs = []

    def dfs2(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in transpose[node]:
            if neighbor not in visited:
                dfs2(neighbor, component)

    for node in reversed(finish_order):
        if node not in visited:
            component = []
            dfs2(node, component)
            sccs.append(component)

    return sccs
```

---

## 4. 최단 경로 알고리즘

### 4.1 Dijkstra's Algorithm

**목적**: 단일 출발점에서 모든 노드로의 최단 경로 (음수 가중치 없음)

**알고리즘**:
```python
import heapq

def dijkstra(graph, start):
    """
    graph: {node: [(neighbor, weight), ...]}
    Returns: {node: distance}
    """
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]  # (distance, node)

    while pq:
        d, u = heapq.heappop(pq)

        if d > dist[u]:
            continue  # 이미 처리됨

        for v, weight in graph[u]:
            new_dist = dist[u] + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))

    return dist
```

**시간 복잡도**: $O((|V| + |E|) \log |V|)$ (binary heap)

**최적화**:
- Fibonacci heap: $O(|V| \log |V| + |E|)$
- 밀집 그래프 ($|E| \approx |V|^2$): 배열 기반 $O(|V|^2)$

**정리**:
Dijkstra는 음수 가중치가 없으면 **최적** 최단 경로 알고리즘

### 4.2 Bellman-Ford Algorithm

**목적**: 음수 가중치 허용, 음수 순환 탐지

**알고리즘**:
```python
def bellman_ford(graph, start):
    """
    graph: {node: [(neighbor, weight), ...]}
    Returns: (distances, has_negative_cycle)
    """
    nodes = list(graph.keys())
    dist = {node: float('inf') for node in nodes}
    dist[start] = 0

    # Relax |V|-1 times
    for _ in range(len(nodes) - 1):
        for u in graph:
            for v, weight in graph[u]:
                if dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight

    # Check for negative cycle
    for u in graph:
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                return dist, True  # Negative cycle exists

    return dist, False
```

**시간 복잡도**: $O(|V| \cdot |E|)$

**정리** (Bellman-Ford Correctness):
$k$ 번째 반복 후, $k$ 엣지 이하로 도달 가능한 모든 노드의 최단 거리가 정확함

### 4.3 Floyd-Warshall Algorithm

**목적**: 모든 쌍 최단 경로 (All-Pairs Shortest Paths)

**알고리즘**:
```python
def floyd_warshall(graph):
    """
    graph: adjacency matrix (2D list/array)
    graph[i][j] = weight of edge i -> j (inf if no edge)
    """
    n = len(graph)
    dist = [row[:] for row in graph]  # Copy

    # dist[i][j] = shortest path from i to j using nodes {0, ..., k-1}
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist
```

**시간 복잡도**: $O(|V|^3)$

**경로 복원**:
```python
def floyd_warshall_with_path(graph):
    n = len(graph)
    dist = [row[:] for row in graph]
    next_node = [[None] * n for _ in range(n)]

    # Initialize next_node
    for i in range(n):
        for j in range(n):
            if graph[i][j] != float('inf') and i != j:
                next_node[i][j] = j

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next_node[i][j] = next_node[i][k]

    def reconstruct_path(i, j):
        if next_node[i][j] is None:
            return []
        path = [i]
        while i != j:
            i = next_node[i][j]
            path.append(i)
        return path

    return dist, reconstruct_path
```

---

## 5. 최소 신장 트리 (MST)

### 5.1 문제 정의

**목표**: 모든 노드를 연결하되 총 가중치가 최소인 트리

**응용**:
- 네트워크 설계 (최소 비용 케이블 연결)
- 클러스터링 (single-linkage)
- 이미지 분할

### 5.2 Kruskal's Algorithm

**아이디어**: 엣지를 가중치 순으로 정렬, 순환을 만들지 않으면 추가

**Union-Find 자료구조** 필요:
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        # Union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(n, edges):
    """
    n: number of nodes
    edges: [(u, v, weight), ...]
    Returns: MST edges
    """
    edges.sort(key=lambda e: e[2])  # Sort by weight
    uf = UnionFind(n)
    mst = []

    for u, v, weight in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            if len(mst) == n - 1:
                break

    return mst
```

**시간 복잡도**: $O(|E| \log |E|)$ (정렬이 지배)

### 5.3 Prim's Algorithm

**아이디어**: 시작 노드에서 트리를 점진적으로 확장

```python
import heapq

def prim(graph, start):
    """
    graph: {node: [(neighbor, weight), ...]}
    Returns: MST edges
    """
    mst = []
    visited = {start}
    edges = [(weight, start, neighbor) for neighbor, weight in graph[start]]
    heapq.heapify(edges)

    while edges:
        weight, u, v = heapq.heappop(edges)
        if v not in visited:
            visited.add(v)
            mst.append((u, v, weight))

            for neighbor, w in graph[v]:
                if neighbor not in visited:
                    heapq.heappush(edges, (w, v, neighbor))

    return mst
```

**시간 복잡도**: $O(|E| \log |V|)$ (binary heap)

---

## 6. 중앙성 (Centrality)

### 6.1 차수 중앙성 (Degree Centrality)

$$
C_D(v) = \deg(v)
$$

**해석**: 직접 연결 수 (local importance)

### 6.2 근접 중앙성 (Closeness Centrality)

$$
C_C(v) = \frac{1}{\sum_{u \ne v} d(v, u)}
$$

**해석**: 다른 노드들과의 평균 거리 (global reachability)

### 6.3 매개 중앙성 (Betweenness Centrality)

$$
C_B(v) = \sum_{s \ne v \ne t} \frac{\sigma_{st}(v)}{\sigma_{st}}
$$
- $\sigma_{st}$: $s$에서 $t$로의 최단 경로 개수
- $\sigma_{st}(v)$: 그 중 $v$를 지나는 개수

**해석**: 네트워크의 "다리" 역할 (information flow)

**계산** (Brandes' Algorithm): $O(|V| \cdot |E|)$

### 6.4 PageRank

**아이디어**: 중요한 노드가 링크한 노드가 중요

**반복식**:
$$
PR(v) = \frac{1-d}{|V|} + d \sum_{u \to v} \frac{PR(u)}{\deg^+(u)}
$$
- $d \approx 0.85$: damping factor

**구현**:
```python
def pagerank(graph, d=0.85, max_iter=100, tol=1e-6):
    nodes = list(graph.keys())
    n = len(nodes)
    pr = {node: 1/n for node in nodes}

    for _ in range(max_iter):
        new_pr = {}
        for v in nodes:
            # Sum from incoming edges
            sum_pr = sum(pr[u] / len(graph[u]) for u in nodes if v in graph[u])
            new_pr[v] = (1 - d) / n + d * sum_pr

        # Check convergence
        if all(abs(new_pr[v] - pr[v]) < tol for v in nodes):
            break

        pr = new_pr

    return pr
```

---

## 7. PyTorch Geometric 구현

### 7.1 BFS/DFS (NetworkX 활용)

```python
import networkx as nx
from torch_geometric.utils import to_networkx

# PyG 그래프를 NetworkX로 변환
G_nx = to_networkx(data, to_undirected=True)

# BFS
bfs_edges = list(nx.bfs_edges(G_nx, source=0))
print("BFS edges:", bfs_edges)

# DFS
dfs_edges = list(nx.dfs_edges(G_nx, source=0))
print("DFS edges:", dfs_edges)
```

### 7.2 최단 경로

```python
# 무가중
shortest_path = nx.shortest_path(G_nx, source=0, target=10)
print("Path:", shortest_path)

# 가중 (Dijkstra)
shortest_path_weighted = nx.dijkstra_path(G_nx, 0, 10, weight='weight')
print("Weighted path:", shortest_path_weighted)

# 모든 쌍 최단 경로
all_pairs = dict(nx.all_pairs_shortest_path_length(G_nx))
```

### 7.3 중앙성

```python
# 차수 중앙성
degree_cent = nx.degree_centrality(G_nx)

# 근접 중앙성
closeness_cent = nx.closeness_centrality(G_nx)

# 매개 중앙성
betweenness_cent = nx.betweenness_centrality(G_nx)

# PageRank
pr = nx.pagerank(G_nx, alpha=0.85)

# 결과 비교
import pandas as pd
df = pd.DataFrame({
    'degree': degree_cent,
    'closeness': closeness_cent,
    'betweenness': betweenness_cent,
    'pagerank': pr
})
print(df.sort_values('pagerank', ascending=False).head(10))
```

---

## 8. 실습 과제

1. **BFS vs DFS 경로 비교**
   - 격자 그래프 ($10 \times 10$)에서 시작→목표 경로 탐색
   - BFS와 DFS의 경로 길이 비교
   - 시각화하여 탐색 순서 관찰

2. **Dijkstra 구현 및 검증**
   - 랜덤 가중 그래프 (100개 노드) 생성
   - 직접 구현한 Dijkstra와 NetworkX 결과 비교
   - 힙 사용 유무에 따른 실행 시간 측정

3. **위상 정렬 응용**
   - 강의 선수 과목 관계를 DAG로 모델링
   - 위상 정렬로 수강 가능한 순서 출력
   - 순환이 있으면 에러 메시지

4. **MST 알고리즘 비교**
   - Kruskal과 Prim을 같은 그래프에 적용
   - MST 가중치 합이 동일한지 확인
   - 실행 시간 비교 (희소 vs 밀집 그래프)

5. **PageRank 분석**
   - 웹 그래프 데이터셋 로드 (예: Stanford SNAP)
   - PageRank 계산 후 상위 10개 노드 추출
   - Damping factor $d$를 변화시키며 순위 변화 관찰

---

## 9. 참고 자료

### 교과서
- Cormen et al., *Introduction to Algorithms* (CLRS), Chapter 22-25
- Kleinberg & Tardos, *Algorithm Design*

### 논문
- Dijkstra (1959), "A Note on Two Problems in Connexion with Graphs"
- Brin & Page (1998), "The Anatomy of a Large-Scale Hypertextual Web Search Engine" (PageRank)
- Brandes (2001), "A Faster Algorithm for Betweenness Centrality"

### 온라인 강의
- MIT 6.006: Introduction to Algorithms
- Coursera: Algorithms on Graphs (UCSD)

---

## 10. 다음 학습

그래프 알고리즘을 마쳤다면:

1. **스펙트럴 그래프 이론**
   - [[스펙트럴 그래프 이론과 GNN|스펙트럴 그래프와 GNN]]
   - Laplacian, 고유값, Graph Convolutional Networks

2. **선형대수와 융합**
   - [[Math/Linear Algebra/고유값과 고유벡터|고유값]]
   - 인접 행렬의 스펙트럴 특성

3. **최적화 연결**
   - [[Math/Optimization/볼록성과 제약 최적화|제약 최적화]]
   - Network flow, max-cut 문제

4. **상위 개념**
   - [[그래프 이론|그래프 이론 허브]]
