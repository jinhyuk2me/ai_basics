## TL;DR
- 푸리에 변환은 신호를 주파수 도메인으로 사상해 합성곱을 곱셈으로 단순화하고, 고주파/저주파 성분을 분리 분석한다.
- CNN 가속(FFT Convolution), Spectral Graph CNN, Stable Audio, Diffusion 모델의 노이즈 스케줄 등에서 필수 도구다.
- NumPy/torch FFT API로 스펙트럼을 시각화하고, 주파수 도메인 필터링을 실습하면 spectral bias를 정량화할 수 있다.

## 언제 쓰나
- 오디오·음성·음악 처리에서 주파수 스펙트럼을 분석하거나 증강할 때
- 대규모 커널 합성곱을 FFT로 가속하거나, Spectral Graph Convolution으로 그래프 필터를 설계할 때
- Diffusion/Score 모델에서 노이즈를 주파수 도메인으로 주입해 안정성을 확보할 때
- CNN/Transformer에서 주파수 대역별 응답을 해석해 모델의 일반화 성질을 분석할 때

## 주요 API
| 개념/연산 | 정의 | NumPy/PyTorch API |
| --- | --- | --- |
| 연속 푸리에 변환 | $F(\omega)=\int_{-\infty}^{\infty} f(t)e^{-i\omega t} dt$ | SymPy `fourier_transform` |
| 이산 푸리에 변환 | $X_k = \sum_{n=0}^{N-1} x_n e^{-i 2\pi k n/N}$ | `numpy.fft.fft`, `torch.fft.fft`
| 역 변환 | $x_n = (1/N) \sum_k X_k e^{i 2\pi k n/N}$ | `ifft`, `irfft`
| STFT | 시간-주파수로 창을 움직여 변환 | `scipy.signal.stft`
| FFT 기반 conv | $y = F^{-1}(F(x) \cdot F(k))$ | `torch.fft.rfft2` + Hadamard product
| Spectral Graph FT | $\hat{f} = U^\top f$ (Laplacian eigenbasis) | `torch.linalg.eigh` + matmul

## 실습 예제
### 1. 1D FFT로 주파수 성분 시각화
```python
import math
import numpy as np

N = 256
fs = 256
t = np.arange(N) / fs
signal = np.sin(2*math.pi*10*t) + 0.5*np.sin(2*math.pi*40*t)
spectrum = np.fft.rfft(signal)
freqs = np.fft.rfftfreq(N, d=1/fs)
print('top frequencies:', freqs[np.argsort(np.abs(spectrum))[-2:]])
```
- 출력은 약 `[10., 40.]`에 피크가 나타난다. 주파수 성분이 분리되어 있는지 확인하는 기본 실험이다.

### 2. FFT 기반 합성곱 vs. 직접 합성곱 시간 비교
```python
import numpy as np

def direct_conv(x, k):
    n, m = len(x), len(k)
    y = np.zeros(n + m - 1)
    for i in range(n):
        for j in range(m):
            y[i+j] += x[i] * k[j]
    return y

def fft_conv(x, k):
    size = len(x) + len(k) - 1
    fft_size = 1 << (size - 1).bit_length()
    X = np.fft.rfft(x, fft_size)
    K = np.fft.rfft(k, fft_size)
    y = np.fft.irfft(X * K, fft_size)
    return y[:size]

x = np.random.randn(1024)
k = np.random.randn(256)
print('direct length:', len(direct_conv(x, k)))
print('fft length:', len(fft_conv(x, k)))
```
- 실제로는 `timeit` 등으로 측정하면 FFT 버전이 $O(n \, log n)$, 직접 합성곱이 $O(nm)$라 길이가 크면 FFT가 훨씬 빠르다.

### 3. 2D 이미지 FFT 필터링
```python
import numpy as np

img = np.random.rand(32, 32)
kernel = np.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]])
fft_size = [img.shape[0] + kernel.shape[0] - 1, img.shape[1] + kernel.shape[1] - 1]
FFT_img = np.fft.rfft2(img, fft_size)
FFT_kernel = np.fft.rfft2(kernel, fft_size)
filtered = np.fft.irfft2(FFT_img * FFT_kernel, fft_size)
print('filtered patch:', filtered[:5, :5])
```
- Sobel 필터와 같은 edge detector를 FFT로 구현하면 대형 커널에서도 효율적으로 적용할 수 있다.

### 4. Spectral Graph Convolution toy 예제
```python
import numpy as np

A = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
D = np.diag(A.sum(axis=1))
L = D - A
vals, vecs = np.linalg.eigh(L)
x = np.array([1., 0., -1.])
filter_coeff = np.array([1., 0.5, 0.2])
# spectral filtering: fhat=vecs^T x -> multiply -> inverse transform
x_hat = vecs.T @ x
filtered = vecs @ (filter_coeff * x_hat)
print('filtered signal:', filtered)
```
- 그래프 라플라시안 고유벡터를 기반으로 주파수 성분을 조정하면 스펙트럴 GNN의 기본 필터링을 재현할 수 있다.

## 실수 주의
- FFT는 주기적 신호를 가정하므로 창 함수(Window)를 사용하지 않으면 경계 불연속으로 인한 leakage가 발생한다.
- `torch.fft` 결과는 복소수 Tensor이므로 `.abs()`를 취해 magnitude를 계산하거나 real/imag를 별도로 처리해야 한다.
- FFT 기반 합성곱에서 zero-padding을 적절히 하지 않으면 circular convolution이 되어 결과가 뒤틀린다.
- Graph FFT에서 라플라시안 고유벡터의 정렬/스케일을 잘못 적용하면 필터가 의도와 다르게 작동한다.
- STFT에서 hop size를 크게 하면 시간 분해능이 떨어지고, 너무 작으면 계산 비용이 폭증한다.

## 관련 노트
- [[Math/Calculus/3. 다변수 미적분]]
- [[Math/Discrete/4. 스펙트럴 그래프 이론과 GNN]]
- [[Operators/3. 합성곱 연산자]]
- [[Math/Numerical/1. 수치 선형대수]]
- [[Math/Math_확장_계획]]
