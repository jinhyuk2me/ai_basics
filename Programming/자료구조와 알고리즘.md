## TL;DR
- 효율적인 자료구조와 알고리즘은 데이터 로딩, 전처리, 탐색, 스케줄링 등 머신러닝 파이프라인 전반에서 성능을 좌우한다.
- Big-O 복잡도를 이해하고 상황에 맞는 구조(배열, 리스트, 힙, 트리, 그래프)를 선택하면 불필요한 병목을 피할 수 있다.
- 기본 알고리즘 패턴(BFS/DFS, 정렬, 동적 계획법)을 익혀두면 모델링 과정에서 발생하는 다양한 서브 문제를 빠르게 해결할 수 있다.

## 핵심 개념
- **시간/공간 복잡도 (Big-O)**
  - 최악/평균/최선 복잡도. 작은 입력에서는 차이를 체감하기 어렵지만, 대용량 데이터 처리에서 결정적.
  - `O(n log n)` vs `O(n^2)`의 차이를 실험으로 확인해 보는 것이 좋다.
- **배열(Array) vs 연결 리스트(Linked List)**
  - 배열: 인덱스 접근 `O(1)`, 삽입/삭제 `O(n)`. PyTorch 텐서와 NumPy 배열은 contiguous memory.
  - 연결 리스트: 삽입/삭제 `O(1)` (포인터만 변경), 랜덤 접근 `O(n)`. Python 리스트는 동적 배열 구조라는 점에 유의.
- **스택·큐·데크**
  - 스택(LIFO)은 재귀/백트래킹, 큐(FIFO)는 BFS·배치 처리, 데크(deque)는 앞뒤 양쪽에서 `O(1)` 삽입/삭제.
  - Python `collections.deque`는 double-ended queue 구현체.
- **힙/우선순위 큐**
  - 최소 힙은 항상 가장 작은 원소를 `O(log n)`에 꺼낼 수 있음. Dijkstra, A* 등에 사용.
  - Python `heapq`는 리스트 기반 힙; push/pop 시 `heapq.heappush`, `heapq.heappop`.
- **트리와 그래프**
  - 트리 순회(전위/중위/후위), 균형 이진트리(BST, AVL, Red-Black).
  - 그래프 표현: adjacency list, adjacency matrix, edge list. 용도에 따라 선택.
  - 위상 정렬(topological sort), 연결 요소, 최소 신장 트리(Prim/Kruskal).
- **정렬 알고리즘**
  - quicksort(평균 `O(n log n)`, 최악 `O(n^2)`), mergesort(`O(n log n)` 안정적), heapsort(`O(n log n)`).
  - Python `sorted`는 Timsort(merge + insertion hybrid) 사용, 대부분의 실제 데이터에서 빠르고 안정적.
- **동적 계획법(DP)**
  - 최적 부분 구조와 중복되는 부분 문제를 갖는 경우, 메모이제이션으로 중복 계산 제거.
  - 예: Fibonacci, knapSack, sequence alignment, beam search에서의 cost caching.

## 예제 스니펫
```python
import heapq
from collections import deque

# BFS using deque
def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    order = []
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return order

# Dijkstra using heapq
def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        current_dist, node = heapq.heappop(pq)
        if current_dist > dist[node]:
            continue
        for neighbor, weight in graph[node]:
            new_dist = current_dist + weight
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
    return dist
```
- BFS는 그래프 탐색, shortest path(무가중치)에 사용되고, 힙 기반 Dijkstra는 양의 가중치 그래프의 최단 경로 알고리즘이다.

## 실습 포인트
- `timeit`을 이용해 Python 리스트에서 `append`, `insert(0, x)`, `pop(0)`의 실행 시간을 측정하고 데크와 비교.
- 무작위 배열을 생성해 quicksort, mergesort, Python `sorted` 성능을 비교.
- 실전 데이터셋(예: 로그 파일)에서 힙을 이용해 상위 k개 요소(Top-K)를 추출하는 유틸리티 작성.
- DP 예제: 편집 거리(edit distance)를 구현하고 문장 유사도를 계산.

## 추천 참고 자료
- *Introduction to Algorithms* (CLRS)
- *Problem Solving with Algorithms and Data Structures using Python*
- Stanford CS97SI, *Programming Contest* 강의 노트

## 다음 학습
- [[Math/Discrete/그래프 이론]]
- [[ML Foundations/학습 패러다임]]
- [[Projects/Project Template]]
